<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spatial: Spatial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Spatial
   </div>
   <div id="projectbrief">Simple Static Analysis in LLVM</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Spatial </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> </p><h1 align="center">SPATIAL: Simple Static Analysis in LLVM</h1>
<h2>Table of Contents</h2>
<ul>
<li>Getting Started<ul>
<li>Building from source</li>
<li>Using with opt</li>
</ul>
</li>
<li>Representing LLVM entities<ul>
<li>Representing LLVM instructions</li>
<li>Representing the operands</li>
<li>Creating a new token</li>
<li>Creating a dummy token</li>
<li>Extracting directly from instruction</li>
</ul>
</li>
<li>Worklist support<ul>
<li>Creating a worklist</li>
<li>Manipulating the worklist</li>
</ul>
</li>
<li>Points-to graph support<ul>
<li>Inserting based on token info</li>
<li>Merging graphs</li>
<li>Retrieving pointee set</li>
</ul>
</li>
<li>Utilities<ul>
<li>Getting predecessors and successors</li>
<li>Can the function be analyzed</li>
</ul>
</li>
<li>Context sensitivity<ul>
<li>Initialize a value context object</li>
<li>Initialize a context</li>
<li>Manipulate dataflow values</li>
<li>Update the context graph</li>
<li>Retrieve the saved contexts</li>
<li>Iterate through the context graph</li>
</ul>
</li>
<li>Benchmarking<ul>
<li>Initialization</li>
<li>Abstracting information from LLVM IR instructions</li>
<li>Evaluating the results</li>
<li>Printing the results</li>
</ul>
</li>
<li>Demo<ul>
<li>Alias Analysis</li>
<li>Demand Driven Alias Analysis</li>
</ul>
</li>
</ul>
<h2>Getting Started</h2>
<p >Spatial is a framework to easily implement analysis over LLVM IR.</p>
<h3>Building from source</h3>
<div class="fragment"><div class="line">$ git clone this_repository.git</div>
<div class="line">$ cd this_repository</div>
<div class="line">$ mkdir build; cd build</div>
<div class="line">$ cmake .. &amp;&amp; make</div>
<div class="line">$ make install</div>
</div><!-- fragment --><h3>Using with opt</h3>
<ul>
<li>Path to shared libary and headers should be searchable by the compiler</li>
<li>In your LLVM IR pass:<ul>
<li>Include the required header file, for example, <code>spatial/Token/AliasToken.h</code></li>
<li>Use namespace <code>spatial</code></li>
</ul>
</li>
<li>Load libSpatial.so before your pass's shared library<ul>
<li><code>opt -load /usr/local/lib/libSpatial.so -load yourPass.so ...</code></li>
</ul>
</li>
</ul>
<h2>Representing LLVM entities</h2>
<p >Spatial provides a common API to deal with all the LLVM's entities, for example, instructions, operands, arguments, global variables and etc. <br  />
</p>
<h3>Representing LLVM instructions</h3>
<p >Spatial represents LLVM instructions by classifying them on the pointer redirection over its operands. <br  />
 For example, an instruction <code>X = *Y</code> can be represented as <code>{(X, 1), (Y, 2)}</code> <br  />
 <code>&amp;X</code> is represented as <code>(X, 0)</code> <br  />
 <code>X</code> is represented as <code>(X, 1)</code> <br  />
 <code>*X</code> is represented as <code>(X, 2)</code> <br  />
 and so on <br  />
</p>
<p >The analysis writer only needs to think about the analysis at various premutations of the indirections for the operand. This way Spatial allow the analysis writer to only write for one instruction in each category. <br  />
</p>
<h3>Representing the operands</h3>
<p >Spatial represets each entity as a token. It provides simple and consistent API calls to various utilities, for example, <br  />
 <code>getName()</code> returns the name of the token <br  />
 <code>isMem()</code> returns true if the token is a memory location <br  />
 more can be found at /lib/Token/Alias.h <br  />
</p>
<h3>Creating a new token</h3>
<p >Directly creating new tokens from the entities is supported but not recommended until required as it requires to the token bank to avoid duplication of tokens. There are cases where we need to explicitly create a token example GEP instructions. <br  />
</p>
<div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;spatial/Token/AliasToken.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacespatial.html">spatial</a></div>
<div class="line">...</div>
<div class="line">for(llvm::StoreInst* SI = llvm::dyn_cast&lt;llvm::StoreInst&gt;(Inst)){</div>
<div class="line">  Alias * X = <span class="keyword">new</span> Alias(SI -&gt; getPointerOperand());</div>
<div class="line">  X = AT.getAliasToken(X);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacespatial_html"><div class="ttname"><a href="namespacespatial.html">spatial</a></div><div class="ttdef"><b>Definition:</b> PointsToBenchmark.cpp:19</div></div>
</div><!-- fragment --><p> AT is an object of AliasTokens class and should be unique to a module. It store all the tokens for a single module getAliasToken returns alias token from AliasTokens either by creating a new one or using the already existing one. <br  />
</p>
<h3>Creating a dummy token</h3>
<p >Creating of dummy token can be useful in few use cases. Spatial supports generation of dummy token,</p>
<div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;spatial/Token/AliasToken.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacespatial.html">spatial</a></div>
<div class="line">...</div>
<div class="line">AT.getAliasToken(&quot;?&quot;, nullptr) <span class="comment">// Creates a dummy alias token with name ? and with global scope</span></div>
</div><!-- fragment --><h3>Extracting directly from instruction</h3>
<p >Spatial provides a clean way to extract information for an instruction. It will also log a warning for any instruction that are not supported right now.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;spatial/Token/AliasToken.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacespatial.html">spatial</a></div>
<div class="line">...</div>
<div class="line">auto AliasVec = AT.extractAliasToken(Inst);</div>
<div class="line"><span class="comment">// AT is the object of AliasTokens</span></div>
<div class="line"><span class="comment">// Inst is a pointer to llvm::Instruction</span></div>
</div><!-- fragment --><h2>Worklist support</h2>
<p >Worklist remains the center of the dataflow analysis. Spatial provides basic support for creating and manipulating worklist at the instruction level. The design does not scale for complex situations, for example, bi-directional analysis; for such cases it is better to implement one on the fly to tailor your needs. <br  />
</p>
<h3>Creating a worklist</h3>
<p >Now create instruction worklist with instructions, basicblock, module and even function. <br  />
</p>
<div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;spatial/include/Worklist/Worklist.h&quot;</span>  </div>
<div class="line">...</div>
<div class="line"><span class="comment">// M is a pointer to LLVM Module</span></div>
<div class="line">spatial::Worklist W(M);</div>
</div><!-- fragment --><h3>Manipulating the worklist</h3>
<p >Spatial allows you to push an instruction, basicblock, module and function into the worklist. It always pops out an instruction. <br  />
</p>
<h2>Points-to graph support</h2>
<p >Spatial provides in built points-to graph supports and also provide features using other parts of the infrastructure. <br  />
</p>
<h3>Inserting based on token info</h3>
<p >Spatial provides direct ways to add points-to information derived for each token. <code>insert(Op1, Op2, R1, R2)</code> takes <code>{(X, 1), (Y, 2)}</code> as <code>insert(X, Y, 1, 2)</code> and inserts the required edge.</p>
<h3>Merging graphs</h3>
<p >Flow-sensitive analysis generally merge values along the branch. Spatial's points-to graph implementation provide easy ways to merge points-to graph. <br  />
 More details at /spatial/include/AliasGraph.h</p>
<h3>Retrieving pointee set</h3>
<p >Spatial provides two methods to retrieve pointee set, <code>getPointee(X)</code> and <code>getUniquePointee(X)</code> <br  />
</p>
<h2>Utilities</h2>
<p >Spatial has spacial utility functions that are frequently used by the analysis writers. More details at /spatial/lib/Utils.cpp</p>
<h3>Getting predecessors and successors</h3>
<p >Spatial provides functions to get instruction successors and predecessors. </p><div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;spatial/Utils/CFGUtils.h&quot;</span></div>
<div class="line">...</div>
<div class="line">auto Pred = <a class="code hl_function" href="namespacespatial.html#afe0b261e835418c8428b64cacdea1776">spatila::GetPred</a>(I);</div>
<div class="line">suto Succ = <a class="code hl_function" href="namespacespatial.html#aed2671a5712d91510e7712d9e6a1b566">spatial::GetSucc</a>(I);</div>
<div class="ttc" id="anamespacespatial_html_aed2671a5712d91510e7712d9e6a1b566"><div class="ttname"><a href="namespacespatial.html#aed2671a5712d91510e7712d9e6a1b566">spatial::GetSucc</a></div><div class="ttdeci">std::vector&lt; llvm::Instruction * &gt; GetSucc(llvm::Instruction *Inst)</div><div class="ttdef"><b>Definition:</b> CFGUtils.cpp:42</div></div>
<div class="ttc" id="anamespacespatial_html_afe0b261e835418c8428b64cacdea1776"><div class="ttname"><a href="namespacespatial.html#afe0b261e835418c8428b64cacdea1776">spatial::GetPred</a></div><div class="ttdeci">std::vector&lt; llvm::Instruction * &gt; GetPred(llvm::Instruction *Inst)</div><div class="ttdef"><b>Definition:</b> CFGUtils.cpp:29</div></div>
</div><!-- fragment --><h3>Can the function be analyzed</h3>
<p >Not all functions are meant to be analyzed, for example, at least the one without a body. Use this utility to skip functions from your analysis. <br  />
 </p><div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;spatial/Utils/CFGUtils.h&quot;</span></div>
<div class="line">...</div>
<div class="line">bool <a class="code hl_function" href="namespacespatial.html#acb4476a68b23a85cbcbd35aaf5ff7cfb">SkipFunction</a> = <a class="code hl_function" href="namespacespatial.html#acb4476a68b23a85cbcbd35aaf5ff7cfb">spatial::SkipFunction</a>(F);</div>
<div class="line">...</div>
<div class="ttc" id="anamespacespatial_html_acb4476a68b23a85cbcbd35aaf5ff7cfb"><div class="ttname"><a href="namespacespatial.html#acb4476a68b23a85cbcbd35aaf5ff7cfb">spatial::SkipFunction</a></div><div class="ttdeci">bool SkipFunction(llvm::Function &amp;F)</div><div class="ttdef"><b>Definition:</b> CFGUtils.cpp:19</div></div>
</div><!-- fragment --><h2>Context sensitivity</h2>
<p >Make your analysis context sensitive at ease with Spatial.</p>
<h3>Initialize a value context object</h3>
<p >Initialize the <code>ValueContext</code> object with the datatype of your dataflow value <br  />
 </p><div class="fragment"><div class="line">ValueContext&lt;AliasMap&gt; VC(BI, Top);</div>
</div><!-- fragment --><h3>Initialize a context</h3>
<p >Initailize a context for a given <code>llvm::Function F</code> and initial dataflow value <code>Initial</code> as follows: <br  />
 </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacespatial.html#ab4ad64b23b2c519620a49644e76e933a">Context</a> C = VC.initializeContext(F, Initial);</div>
<div class="ttc" id="anamespacespatial_html_ab4ad64b23b2c519620a49644e76e933a"><div class="ttname"><a href="namespacespatial.html#ab4ad64b23b2c519620a49644e76e933a">spatial::Context</a></div><div class="ttdeci">int Context</div><div class="ttdef"><b>Definition:</b> ValueContext.h:11</div></div>
</div><!-- fragment --><h3>Manipulate dataflow values</h3>
<p >Manipulate data structures storing dataflow values directly through <code>getDataFlowIn</code> and <code>getDataFlowOut</code> <br  />
 </p><div class="fragment"><div class="line"><span class="keyword">auto</span> DataflowValue = VC.getDataFlowIn[<a class="code hl_typedef" href="namespacespatial.html#ab4ad64b23b2c519620a49644e76e933a">Context</a>][Instruction];</div>
</div><!-- fragment --><h3>Update the context graph</h3>
<p >You may want to update the context graph after initializing a new context. <br  />
 </p><div class="fragment"><div class="line">VC.updateContextGraph(InitialContext, NewContext, CallSite);</div>
</div><!-- fragment --><h3>Retrieve the saved contexts</h3>
<p >To get the previously saved context for a given <code>llvm::Function F</code> and initial dataflow value <code>Initial</code> do as follow: <br  />
 </p><div class="fragment"><div class="line"><span class="keyword">auto</span> SavedContext = VC.getSavedContext(F, Initial);</div>
</div><!-- fragment --><p> if the value of <code>SavedContext</code> is less than 0, implies that this context was not saved previously. <br  />
</p>
<h3>Set result for a saved context</h3>
<p >When you reach the boundary instruction, you may want to update the result for the context <code>C</code> </p><div class="fragment"><div class="line">VC.setResult(C, DataflowResutant);</div>
</div><!-- fragment --><h3>Iterate through the context graph</h3>
<p >To iterate over all the contexts which invoked this context using a function call </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> T : VC.getContextChild(C)) {</div>
<div class="line">    <span class="comment">// For a context Child which called the context C though callsite Inst</span></div>
<div class="line">    <span class="comment">// T is the pair of Child and Inst</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Benchmarking</h2>
<p >Spatial provides support for analysis benchmarking starting with alias analysis. The present implementation relies on trigger functions, for example, <code>MAY_ALIAS(a,b)</code></p>
<h3>Initialization</h3>
<p >Create an instance and use it for extracting benchmark data and evaluations </p><div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;spatial/Benchmark/Benchmark.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacespatial.html">spatial</a></div>
<div class="line">...</div>
<div class="line">BenchmarkRunner Bench;</div>
</div><!-- fragment --><ul>
<li><code>AT</code> is an object of <code>AliasTokens</code> class and should be unique to a module. It store all the tokens for a single module</li>
<li><code>getAliasToken</code> returns alias token from <code>AliasTokens</code> either by creating a new one or using the already existing one.</li>
</ul>
<h3>Abstracting information from LLVM IR instructions</h3>
<p >It will react to specific function calls and will extract out information for its arguments. </p><div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;spatial/Benchmark/Benchmark.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacespatial.html">spatial</a></div>
<div class="line">...</div>
<div class="line">BenchmarkRunner Bench;</div>
<div class="line"><span class="comment">// Inst is the pointer to a LLVM Instruction </span></div>
<div class="line"><span class="keyword">auto</span> BenchVars = Bench.extract(Inst); </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(BenchVars.size() == 2) {</div>
<div class="line">    <span class="comment">// We found a specific call we care about</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Evaluating the results</h3>
<p >Use the function evaluate for evaluating the results. </p><div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;spatial/Benchmark/Benchmark.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacespatial.html">spatial</a></div>
<div class="line">...</div>
<div class="line">BenchmarkRunner Bench;</div>
<div class="line"><span class="comment">// Inst is the pointer to a LLVM Instruction </span></div>
<div class="line"><span class="keyword">auto</span> BenchVars = Bench.extract(Inst); </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(BenchVars.size() == 2) {</div>
<div class="line">    Bench.evaluate(Inst, PointeeSet(BenchVars[0]), PointeeSet(BenchVars[1]));</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Printing the results</h3>
<div class="fragment"><div class="line">std::cout &lt;&lt; Bench;</div>
</div><!-- fragment --><h2>Demo</h2>
<p >Spatial stands on the shoulders of extensive experience gained from implementing alias analysis. To demonstrate its usefulness and robustness, we implemented a flow-sensitive and context-sensitive variant of alias analysis and also a demand demand driven variants. These implementations can also be used a reference.</p>
<h3>Alias Analysis</h3>
<p ><a href="https://github.com/reSHARMA/AliasAnalysis">Github repo</a></p>
<h3>Demand Driven Alias Analysis</h3>
<p ><a href="https://github.com/reSHARMA/DemandDrivenAliasAnalysis/">Github repo</a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
